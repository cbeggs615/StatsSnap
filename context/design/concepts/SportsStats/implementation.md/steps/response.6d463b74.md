---
timestamp: 'Wed Oct 15 2025 13:55:15 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251015_135515.23d2f6bc.md]]'
content_id: 6d463b74f6727999124f3764722a5aec177dd5e74b0f9ecec71e0968f1d0f3aa
---

# response:

These are excellent clarifying questions that get to the heart of concept design principles like separation of concerns, completeness of functionality, and polymorphism.

Let's address them one by one:

***

### Question 1: "so could source in these cases for each sport be say updated using an api?"

Yes, but it's important to understand *how* that would happen within the concept design paradigm.

1. **Within the `SportsStats` Concept:** The `SportsStats` concept itself, as specified and implemented, does not have an action to *update* the `Source` associated with a `Sport` after it's been added. It only has `addSport` to create a new sport with a source, and `deleteSport` to remove it. If you needed to change a sport's source, you would have to add an `updateSportSource` action to the `SportsStats` concept's specification and implementation. This action would require finding the sport and then updating its `source` field.

2. **External APIs and Syncs:**

   * The `Source` generic parameter (which we define as `ID`) is an **opaque identifier** from the perspective of the `SportsStats` concept. The concept stores this ID but doesn't "know" what it means beyond being an identifier. It doesn't interpret it as a URL, an API endpoint, or credentials.
   * Therefore, the `SportsStats` concept itself would **not** directly "update a source using an API" in the sense of making an external network call. That would violate the concept's independence and completeness of functionality, as it would mean `SportsStats` is directly coupled to an external service.
   * Instead, in a larger application using concept design, an *external* mechanism (likely a `sync` or another specialized concept, say `ExternalDataProvider`) would be responsible for:
     * **Interpreting the `Source` ID:** This external mechanism would know what the `Source` ID refers to (e.g., "ESPN" could mean "call the ESPN API with these credentials").
     * **Calling the External API:** It would make the actual network requests to the external API (e.g., ESPN's API) to fetch data.
     * **Updating `SportsStats`:** Once data is retrieved, this external mechanism would then call internal or public actions on the `SportsStats` concept to update the statistics. For example, it might call the `_setStatValue` internal action I included, or a dedicated `updateStatValue` action if it were made public.

   So, to directly answer: "could source in these cases for each sport be say updated using an api?", the `Source` *field* of a `Sport` could be updated by a new action in `SportsStatsConcept`. But the *data originating from* that `Source` (which might come from an external API) would typically be brought *into* `SportsStats` through `syncs` that orchestrate interactions between `SportsStats` and other concepts/external services.

***

### Question 2: "each sport would have a different source. is it assumed that when each sport is added, we transform this source into the format source is in this spec?"

No, transformation is generally not assumed or required *by the concept itself*.

1. **`Source` as an Opaque `ID`:** As defined in the `SportsStats` concept, `Source` is a generic type, which we've implemented as an `ID` (a branded string). This means the `SportsStats` concept simply stores whatever string ID it's given for the `Source` field. It doesn't perform any validation or transformation on this string.
2. **Polymorphism and Caller Responsibility:** This is an example of polymorphism at play. The `SportsStats` concept is designed to be as general as possible. It accepts `Source` as an abstract identifier. It's the responsibility of the *caller* of the `addSport` action (e.g., the application logic, another concept, or a `sync` that orchestrates sport creation) to provide a `Source` `ID` that is consistent and meaningful within the larger application's context.
   * For example, if your application uses a `SportsAPIConfig` concept to manage external API configurations, then the `Source` ID for a sport might be an ID generated by `SportsAPIConfig` when an API configuration is registered.
   * The "transformation" you refer to would happen *before* the `addSport` action is called, by the part of the system that understands what that raw external source (e.g., a complex URL, an API object) needs to be represented as an `ID` for storage in `SportsStats`.

In essence, the `SportsStats` concept declares *what* information it needs (`Sport` has a `Source` ID), but it doesn't dictate *how* that `Source` ID is obtained or what deeper meaning it holds externally. This separation allows `SportsStats` to remain independent and reusable, without needing to know the specifics of every possible external data provider.
