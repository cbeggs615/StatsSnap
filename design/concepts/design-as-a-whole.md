## Interesting moments
1.  When making my PasswordAuth, I decided to have context try to further revise by making it use hashing, and although it took two tries, I was very happy with the results. Additionally, I was very happy when it continued to pass the same test cases implying rep independence. [PasswordAuth with Hashing](../../context/design/concepts/PasswordAuth/implementation.md/20251016_213050.9707f256.md)
2. Better understanding how my SportsStats concept would work. Originally, I was imagining that the SportsStats Concept itself would be calling the API, but through prompting with context, I realized that the actual data updating would be handled via a sync. Thus, it is a more generalizable way so that the data can be fetched from a specific source, but how that data is updated is an implementation detail. Basically, the source line could then be used to decipher how to handle how/when to update the data from the source in the sync. [Talking about SportsStats Logistics](../../context/design/concepts/SportsStats/testing.md/20251016_231112.b7059864.md)
3.  Realizing how effective context/LLMs were with refactoring test cases. I struggled having context create the test cases (although looking at the context files, I may have improperly linked the testing-concepts file). However, once I created a deno initial test suite, I had context refactor to better represent scenarios which better aligned with the assignment. [Refactoring Test Cases](context/design/concepts/SportsStats/testing.md/20251016_230737.ec5f3bb1.md)
4. When checking my implementations with the spec, the LLM noticed that the implementation (which it had helped created) of associateItem in StreamedEvents did not align with the spec for the case where the item did not exist yet. This was super interesting because it was something I had blown over when I checked the spec myself. It showed me the value of another set of eyes (even if its really an LLM) checking the code. [AssociateItem doesn't match spec](../../context/design/concepts/StreamedEvents/implementation.md/20251019_103834.3ea001e9.md)
5.  I found it interesting how much the LLM struggled with dealing with typechecking in TypeScript when I was having it refactor my test cases. It had trouble accounting for the case where functions were supposed to return promise with either the ideal return or an error string. [LLM generating test cases that don't account for TS typechecking](../../context/design/concepts/SportsStats/testing.md/20251016_231112.b7059864.md)